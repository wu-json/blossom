# Bun Native File Embeddings for Asset Bundling

**Date:** 2025-12-21
**Status:** Validated - Ready for Implementation

## Overview

Replace the current base64-encoding approach in `scripts/embed-assets.ts` with Bun's native file embedding via `import ... with { type: "file" }`. This removes the encoding/decoding overhead and leverages Bun's built-in static file serving.

## Current Approach (Problems)

The existing `scripts/embed-assets.ts` works as follows:

1. Runs `bunx vite build` to produce `.vite-build/`
2. Scans all output files
3. For binary files (images, fonts): base64-encodes content
4. For text files (JS, CSS, HTML): stores as raw strings
5. Generates `src/generated/embedded-assets.ts` with a large JSON object (~500KB)
6. Server imports this JSON and serves assets, decoding base64 at runtime

**Problems:**
- Base64 encoding increases size by ~33%
- Runtime decoding adds CPU overhead per request
- Generated TypeScript file is massive
- Doesn't use Bun's native capabilities

## Proposed Approach

Use Bun's `with { type: "file" }` import attribute to embed files natively into the compiled binary.

### How Bun File Embedding Works

```typescript
import icon from "./icon.png" with { type: "file" };

// During development: "./icon.png"
// After bun --compile: "$bunfs/icon-a1b2c3d4.png" (internal path)

// Access the file:
const blob = Bun.file(icon);
const bytes = await blob.arrayBuffer();
```

Key features:
- Files are embedded directly into the binary
- No base64 encoding - stored as raw bytes
- `Bun.file()` returns a Blob with correct MIME type
- `Bun.embeddedFiles` lists all embedded files at runtime

### New Build Script

The new `scripts/embed-assets.ts` would:

1. Run Vite build (same as now)
2. Scan `.vite-build/` for all files
3. Generate a TypeScript file with:
   - Import statements using `with { type: "file" }`
   - A mapping from URL paths to imported file paths

**Generated output:**
```typescript
// Auto-generated by scripts/embed-assets.ts - do not edit
import _index_html from "../.vite-build/index.html" with { type: "file" };
import _assets_index_abc123_js from "../.vite-build/assets/index-abc123.js" with { type: "file" };
import _assets_index_def456_css from "../.vite-build/assets/index-def456.css" with { type: "file" };

export const assets: Record<string, string> = {
  "/index.html": _index_html,
  "/assets/index-abc123.js": _assets_index_abc123_js,
  "/assets/index-def456.css": _assets_index_def456_css,
};
```

### Server Changes

**Option A: Use `Bun.serve({ static: ... })`**

```typescript
import { assets } from "./generated/embedded-assets";

Bun.serve({
  static: Object.fromEntries(
    Object.entries(assets).map(([path, file]) => [path, Bun.file(file)])
  ),
  fetch(req) {
    // API routes and SPA fallback
  },
});
```

**Option B: Manual serving in fetch handler**

```typescript
import { assets } from "./generated/embedded-assets";

// In fetch handler:
const asset = assets[pathname];
if (asset) {
  return new Response(Bun.file(asset));
}

// SPA fallback
if (!pathname.startsWith("/api/") && assets["/index.html"]) {
  return new Response(Bun.file(assets["/index.html"]));
}
```

### Benefits

| Aspect | Current (base64) | Proposed (Bun file) |
|--------|-----------------|---------------------|
| Binary size | +33% overhead | Native size |
| Runtime decode | Yes (CPU cost) | No |
| Generated TS file | ~500KB JSON | ~5KB imports |
| Content-Type | Manual mapping | Automatic via Bun.file() |
| Static serving | Custom code | `Bun.serve({ static })` |

## Feasibility Validation

All key aspects have been validated with working tests (Bun 1.3.4).

### 1. Can Vite output files be imported with `type: "file"`?

**✅ Validated.** The import paths are generated after Vite build, so we know the exact filenames (including hashes). The build script generates valid import statements.

```typescript
import readmePath from "/path/to/README.md" with { type: "file" };
console.log(readmePath); // Works in both dev and compiled modes
```

### 2. Does this work with `bun --compile`?

**✅ Validated.** This is exactly what `with { type: "file" }` is designed for:

```
# Development mode:
README path: /Users/.../README.md

# After bun --compile:
README path: /$bunfs/root/README-f753fzas.md
```

The `$bunfs` virtual filesystem paths work correctly with `Bun.file()`.

### 3. Does HTTP serving work with embedded files?

**✅ Validated.** The following pattern works in compiled binaries:

```typescript
const assets: Record<string, string> = {
  "/README.md": readmePath,      // "/$bunfs/root/README-xxx.md"
  "/package.json": pkgPath,      // "/$bunfs/root/package-xxx.json"
};

// In fetch handler:
const assetPath = assets[pathname];
if (assetPath) {
  return new Response(Bun.file(assetPath));
}
```

Test results from compiled binary:
```
GET /README.md
  Status: 200
  Content-Type: text/markdown

GET /package.json
  Status: 200
  Content-Type: application/json;charset=utf-8
```

### 4. Does `Bun.embeddedFiles` work?

**✅ Validated.** The embedded files are accessible at runtime:

```typescript
for (const blob of Bun.embeddedFiles) {
  console.log(blob.name, blob.size, "bytes");
}
// Output (in compiled binary):
// README-f753fzas.md 961 bytes
// package-gnkkfstk.json 936 bytes
```

### 5. Content-Type handling

**✅ Validated.** `Bun.file()` automatically determines Content-Type from the file extension:

| Extension | Returned Content-Type |
|-----------|----------------------|
| `.md` | `text/markdown` |
| `.json` | `application/json;charset=utf-8` |
| `.html` | `text/html;charset=utf-8` |
| `.js` | `text/javascript;charset=utf-8` |
| `.css` | `text/css;charset=utf-8` |

This eliminates the need for our manual `contentTypes` mapping.

### 6. SPA fallback approach

**Recommended: Manual fallback in fetch handler.** This gives us full control:

```typescript
// After API routes, before 404
if (!pathname.startsWith("/api/")) {
  const indexPath = assets["/index.html"];
  if (indexPath) {
    return new Response(Bun.file(indexPath), {
      headers: { "Content-Type": "text/html; charset=utf-8" },
    });
  }
}
```

## Implementation Plan

### Phase 1: Build Script Rewrite

Replace `scripts/embed-assets.ts`:

```typescript
import { $ } from "bun";
import { join } from "node:path";

const rootDir = join(import.meta.dir, "..");
const viteBuildDir = join(rootDir, ".vite-build");
const outputFile = join(rootDir, "src", "generated", "embedded-assets.ts");

async function main() {
  console.log("Building frontend with Vite...");
  await $`bunx vite build`.cwd(rootDir);

  console.log("Scanning built files...");
  const files = await Array.fromAsync(
    new Bun.Glob("**/*").scan({ cwd: viteBuildDir, dot: false })
  );

  // Filter to actual files (not directories)
  const assetFiles: string[] = [];
  for (const file of files) {
    const fullPath = join(viteBuildDir, file);
    const bunFile = Bun.file(fullPath);
    if ((await bunFile.exists()) && bunFile.size > 0) {
      assetFiles.push(file);
    }
  }

  console.log(`Found ${assetFiles.length} files to embed`);

  // Generate import statements
  const imports: string[] = [];
  const mappings: string[] = [];

  for (const file of assetFiles) {
    // Create valid identifier from path
    const identifier = "_" + file.replace(/[^a-zA-Z0-9]/g, "_");
    const urlPath = "/" + file;
    const importPath = `../.vite-build/${file}`;

    imports.push(`import ${identifier} from "${importPath}" with { type: "file" };`);
    mappings.push(`  "${urlPath}": ${identifier},`);

    console.log(`  ${urlPath}`);
  }

  const output = `// Auto-generated by scripts/embed-assets.ts - do not edit
${imports.join("\n")}

export const assets: Record<string, string> = {
${mappings.join("\n")}
};
`;

  await Bun.write(outputFile, output);
  console.log(`\nGenerated ${outputFile}`);
}

main().catch((err) => {
  console.error("Error:", err);
  process.exit(1);
});
```

### Phase 2: Server Updates

Update `src/index.ts` to use new asset format:

```typescript
import { assets } from "./generated/embedded-assets";

// In fetch handler static file serving:
if (pathname === "/") {
  pathname = "/index.html";
}

const assetPath = assets[pathname];
if (assetPath) {
  return new Response(Bun.file(assetPath));
}

// SPA fallback
const indexPath = assets["/index.html"];
if (indexPath && !pathname.startsWith("/api/")) {
  return new Response(Bun.file(indexPath), {
    headers: { "Content-Type": "text/html; charset=utf-8" },
  });
}
```

### Phase 3: TypeScript Declaration

Add type declaration for the import attribute:

```typescript
// src/types/bun-file.d.ts
declare module "*.html" {
  const path: string;
  export default path;
}

declare module "*.js" {
  const path: string;
  export default path;
}

declare module "*.css" {
  const path: string;
  export default path;
}

// ... etc for other file types
```

## Testing Plan

1. **Development mode**: Run `bun --hot ./src/index.ts` and verify assets serve correctly
2. **Built binary**: Run `just build`, execute binary, verify assets serve correctly
3. **Content-Types**: Check response headers for various file types
4. **SPA routing**: Navigate to `/chat/123` and verify `index.html` is served
5. **Binary files**: Verify images/fonts load correctly (no corruption from encoding)
6. **Performance**: Compare response times vs base64 approach

## Risks & Mitigations

| Risk | Status | Mitigation |
|------|--------|------------|
| `Bun.file()` doesn't work with `$bunfs` paths | ✅ Validated - works | N/A |
| TypeScript errors on import attributes | Low risk | Add proper `.d.ts` declarations |
| `static` routes don't support embedded files | Low risk | Use manual serving in fetch handler (validated approach) |
| Development mode breaks (no compiled binary) | ✅ Validated - works | `Bun.file()` works with regular paths in dev mode |

## Open Questions

1. **Should we use `Bun.serve({ static })` or manual serving?**
   - **Recommendation:** Start with manual serving in fetch handler (validated approach)
   - Can optimize to `static` routes later if needed for performance
   - Manual serving gives us full control over SPA fallback

2. **How to handle cache headers?**
   - Vite adds hashes to filenames for cache busting
   - We should add `Cache-Control: max-age=31536000` for hashed assets in `/assets/`
   - `index.html` should have `Cache-Control: no-cache`

3. **Is `Bun.embeddedFiles` needed as fallback?**
   - Not needed for primary implementation
   - Useful for debugging to verify files are embedded correctly
   - Could be used as runtime fallback if mapping fails

## References

- [Bun File Types Documentation](https://bun.sh/docs/runtime/file-types)
- [Bun Bundler - Executables](https://bun.sh/docs/bundler/executables)
- [Current embed-assets.ts](../scripts/embed-assets.ts)
