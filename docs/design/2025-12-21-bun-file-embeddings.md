# Bun Native File Embeddings for Asset Bundling

**Date:** 2025-12-21
**Status:** Validated - Ready for Implementation

## Overview

Replace the current base64-encoding approach in `scripts/embed-assets.ts` with Bun's native file embedding via `import ... with { type: "file" }`. This removes the encoding/decoding overhead and leverages Bun's built-in static file serving.

## Development vs Production

**Development mode:**
- Vite dev server serves frontend (port 5173)
- Bun serves API only (port 3000)
- Embedded assets are NOT used - Vite handles hot reload

**Production mode:**
- `scripts/embed-assets.ts` runs Vite build, generates imports
- `bun build --compile` embeds assets into binary
- Single binary serves both API and frontend

This design only affects production builds. Development workflow is unchanged.

**Edge case:** In dev mode, `src/generated/embedded-assets.ts` imports from `.vite-build/` which may not exist. Two options:

1. **Conditional import** - Check if running in compiled mode before using assets
2. **Stub file** - Keep a minimal stub checked into git that gets overwritten on build

Option 2 is simpler. The stub would be:
```typescript
// Stub for development - overwritten by scripts/embed-assets.ts on build
export const assets: Record<string, string> = {};
```

In dev mode, `assets` is empty, so the server falls through to 404 (which is fine - Vite serves assets). In prod, the real file with imports is used.

## Current Approach (Problems)

The existing `scripts/embed-assets.ts` works as follows:

1. Runs `bunx vite build` to produce `.vite-build/`
2. Scans all output files
3. For binary files (images, fonts): base64-encodes content
4. For text files (JS, CSS, HTML): stores as raw strings
5. Generates `src/generated/embedded-assets.ts` with a large JSON object (~500KB)
6. Server imports this JSON and serves assets, decoding base64 at runtime

**Problems:**
- Base64 encoding increases size by ~33%
- Runtime decoding adds CPU overhead per request
- Generated TypeScript file is massive
- Doesn't use Bun's native capabilities

## Proposed Approach

Use Bun's `with { type: "file" }` import attribute to embed files natively into the compiled binary.

### How Bun File Embedding Works

```typescript
import icon from "./icon.png" with { type: "file" };

// During development: "./icon.png"
// After bun --compile: "$bunfs/icon-a1b2c3d4.png" (internal path)

// Access the file:
const blob = Bun.file(icon);
const bytes = await blob.arrayBuffer();
```

Key features:
- Files are embedded directly into the binary
- No base64 encoding - stored as raw bytes
- `Bun.file()` returns a Blob with correct MIME type
- `Bun.embeddedFiles` lists all embedded files at runtime

### New Build Script

The new `scripts/embed-assets.ts` would:

1. Run Vite build (same as now)
2. Scan `.vite-build/` for all files
3. Generate a TypeScript file with:
   - Import statements using `with { type: "file" }`
   - A mapping from URL paths to imported file paths

**Generated output:**
```typescript
// Auto-generated by scripts/embed-assets.ts - do not edit
import _index_html from "../.vite-build/index.html" with { type: "file" };
import _assets_index_abc123_js from "../.vite-build/assets/index-abc123.js" with { type: "file" };
import _assets_index_def456_css from "../.vite-build/assets/index-def456.css" with { type: "file" };

export const assets: Record<string, string> = {
  "/index.html": _index_html,
  "/assets/index-abc123.js": _assets_index_abc123_js,
  "/assets/index-def456.css": _assets_index_def456_css,
};
```

### Server Changes

**Option A: Use `Bun.serve({ static: ... })`**

```typescript
import { assets } from "./generated/embedded-assets";

Bun.serve({
  static: Object.fromEntries(
    Object.entries(assets).map(([path, file]) => [path, Bun.file(file)])
  ),
  fetch(req) {
    // API routes and SPA fallback
  },
});
```

**Option B: Manual serving in fetch handler**

```typescript
import { assets } from "./generated/embedded-assets";

// In fetch handler:
const asset = assets[pathname];
if (asset) {
  return new Response(Bun.file(asset));
}

// SPA fallback
if (!pathname.startsWith("/api/") && assets["/index.html"]) {
  return new Response(Bun.file(assets["/index.html"]));
}
```

### Benefits

| Aspect | Current (base64) | Proposed (Bun file) |
|--------|-----------------|---------------------|
| Binary size | +33% overhead | Native size |
| Runtime decode | Yes (CPU cost) | No |
| Generated TS file | ~500KB JSON | ~5KB imports |
| Content-Type | Manual mapping | Automatic via Bun.file() |
| Static serving | Custom code | `Bun.serve({ static })` |

## Feasibility Validation

All key aspects have been validated with working tests (Bun 1.3.4).

### 1. Can Vite output files be imported with `type: "file"`?

**✅ Validated.** The import paths are generated after Vite build, so we know the exact filenames (including hashes). The build script generates valid import statements.

```typescript
import readmePath from "/path/to/README.md" with { type: "file" };
console.log(readmePath); // Works in both dev and compiled modes
```

### 2. Does this work with `bun --compile`?

**✅ Validated.** This is exactly what `with { type: "file" }` is designed for:

```
# Development mode:
README path: /Users/.../README.md

# After bun --compile:
README path: /$bunfs/root/README-f753fzas.md
```

The `$bunfs` virtual filesystem paths work correctly with `Bun.file()`.

### 3. Does HTTP serving work with embedded files?

**✅ Validated.** The following pattern works in compiled binaries:

```typescript
const assets: Record<string, string> = {
  "/README.md": readmePath,      // "/$bunfs/root/README-xxx.md"
  "/package.json": pkgPath,      // "/$bunfs/root/package-xxx.json"
};

// In fetch handler:
const assetPath = assets[pathname];
if (assetPath) {
  return new Response(Bun.file(assetPath));
}
```

Test results from compiled binary:
```
GET /README.md
  Status: 200
  Content-Type: text/markdown

GET /package.json
  Status: 200
  Content-Type: application/json;charset=utf-8
```

### 4. Does `Bun.embeddedFiles` work?

**✅ Validated.** The embedded files are accessible at runtime:

```typescript
for (const blob of Bun.embeddedFiles) {
  console.log(blob.name, blob.size, "bytes");
}
// Output (in compiled binary):
// README-f753fzas.md 961 bytes
// package-gnkkfstk.json 936 bytes
```

### 5. Content-Type handling

**✅ Validated.** `Bun.file()` automatically determines Content-Type from the file extension:

| Extension | Returned Content-Type |
|-----------|----------------------|
| `.md` | `text/markdown` |
| `.json` | `application/json;charset=utf-8` |
| `.html` | `text/html;charset=utf-8` |
| `.js` | `text/javascript;charset=utf-8` |
| `.css` | `text/css;charset=utf-8` |

This eliminates the need for our manual `contentTypes` mapping.

### 6. SPA fallback approach

**Recommended: Manual fallback in fetch handler.** This gives us full control:

```typescript
// After API routes, before 404
if (!pathname.startsWith("/api/")) {
  const indexPath = assets["/index.html"];
  if (indexPath) {
    return new Response(Bun.file(indexPath), {
      headers: { "Content-Type": "text/html; charset=utf-8" },
    });
  }
}
```

## Implementation Plan

### Phase 1: Build Script Rewrite

Replace `scripts/embed-assets.ts`:

```typescript
import { $ } from "bun";
import { join } from "node:path";

const rootDir = join(import.meta.dir, "..");
const viteBuildDir = join(rootDir, ".vite-build");
const outputFile = join(rootDir, "src", "generated", "embedded-assets.ts");

async function main() {
  console.log("Building frontend with Vite...");
  const result = await $`bunx vite build`.cwd(rootDir).nothrow();

  if (result.exitCode !== 0) {
    console.error("Vite build failed:");
    console.error(result.stderr.toString());
    process.exit(1);
  }

  console.log("Scanning built files...");
  const files = await Array.fromAsync(
    new Bun.Glob("**/*").scan({ cwd: viteBuildDir, dot: false })
  );

  // Filter to actual files (not directories)
  const assetFiles: string[] = [];
  for (const file of files) {
    const fullPath = join(viteBuildDir, file);
    const bunFile = Bun.file(fullPath);
    if ((await bunFile.exists()) && bunFile.size > 0) {
      assetFiles.push(file);
    }
  }

  if (assetFiles.length === 0) {
    console.error("No files found in .vite-build/ - build may have failed");
    process.exit(1);
  }

  console.log(`Found ${assetFiles.length} files to embed`);

  // Generate import statements with unique identifiers
  const imports: string[] = [];
  const mappings: string[] = [];

  for (let i = 0; i < assetFiles.length; i++) {
    const file = assetFiles[i];
    // Use index to guarantee unique identifiers (avoids collision from similar paths)
    const identifier = `_asset${i}`;
    const urlPath = "/" + file;
    const importPath = `../.vite-build/${file}`;

    imports.push(`import ${identifier} from "${importPath}" with { type: "file" };`);
    mappings.push(`  "${urlPath}": ${identifier}, // ${file}`);

    console.log(`  ${urlPath}`);
  }

  const output = `// Auto-generated by scripts/embed-assets.ts - do not edit
${imports.join("\n")}

export const assets: Record<string, string> = {
${mappings.join("\n")}
};
`;

  await Bun.write(outputFile, output);
  console.log(`\nGenerated ${outputFile}`);
}

main().catch((err) => {
  console.error("Error:", err);
  process.exit(1);
});
```

### Phase 2: Server Updates

Update `src/index.ts` to use new asset format:

```typescript
import { assets } from "./generated/embedded-assets";

// In fetch handler static file serving:
if (pathname === "/") {
  pathname = "/index.html";
}

const assetPath = assets[pathname];
if (assetPath) {
  // Hashed assets (in /assets/) can be cached forever
  // index.html should not be cached (may reference new hashed assets)
  const isHashedAsset = pathname.startsWith("/assets/");
  const cacheControl = isHashedAsset
    ? "public, max-age=31536000, immutable"
    : "no-cache";

  return new Response(Bun.file(assetPath), {
    headers: { "Cache-Control": cacheControl },
  });
}

// SPA fallback - serve index.html for client-side routes
const indexPath = assets["/index.html"];
if (indexPath && !pathname.startsWith("/api/")) {
  return new Response(Bun.file(indexPath), {
    headers: {
      "Content-Type": "text/html; charset=utf-8",
      "Cache-Control": "no-cache",
    },
  });
}
```

### Phase 3: TypeScript Declaration

The generated file imports from `.vite-build/` which only exists after a production build. TypeScript needs to know these imports return strings.

**Option A: Ambient declaration (may conflict with Vite in dev)**
```typescript
// src/types/bun-file.d.ts
declare module "*.html" {
  const path: string;
  export default path;
}
// ... etc
```

**Option B: Inline type assertion in generated file (recommended)**

Generate the file with explicit types, avoiding global declarations:
```typescript
// Auto-generated - do not edit
import _asset0 from "../.vite-build/index.html" with { type: "file" };
import _asset1 from "../.vite-build/assets/index-abc.js" with { type: "file" };

export const assets: Record<string, string> = {
  "/index.html": _asset0 as string,
  "/assets/index-abc.js": _asset1 as string,
};
```

This avoids polluting the global module namespace and won't conflict with Vite's dev server handling.

**Note:** Bun's TypeScript support already understands `with { type: "file" }` imports, so this may work without any declarations. Test before adding.

## Build Integration

The build flow in `justfile`:

```bash
build:
  bun run scripts/embed-assets.ts    # 1. Vite build + generate imports
  goreleaser build --clean --snapshot # 2. bun build --compile (embeds files)
```

**Critical dependency:** `scripts/embed-assets.ts` MUST run before goreleaser. The generated `src/generated/embedded-assets.ts` file must exist with valid imports pointing to `.vite-build/` files before `bun build --compile` runs.

Goreleaser config (`.goreleaser.yaml`) uses:
```yaml
flags:
  - --compile
  - --minify
```

The `--compile` flag triggers Bun's file embedding for all `with { type: "file" }` imports.

## Testing Plan

1. **Development mode**: Run `curse` (Vite + API) - assets served by Vite, not embedded
2. **Production build**: Run `just build`, execute binary, verify assets serve correctly
3. **Content-Types**: Check response headers for various file types
4. **Cache headers**: Verify `/assets/*` has `immutable`, `index.html` has `no-cache`
5. **SPA routing**: Navigate to `/chat/123` and verify `index.html` is served
6. **Binary files**: Verify images/fonts load correctly (no corruption from encoding)

## Risks & Mitigations

| Risk | Status | Mitigation |
|------|--------|------------|
| `Bun.file()` doesn't work with `$bunfs` paths | ✅ Validated - works | N/A |
| TypeScript errors on import attributes | Low risk | Add proper `.d.ts` declarations |
| `static` routes don't support embedded files | Low risk | Use manual serving in fetch handler (validated approach) |
| Development mode breaks (no compiled binary) | ✅ Validated - works | `Bun.file()` works with regular paths in dev mode |

## Open Questions

1. **Should we use `Bun.serve({ static })` or manual serving?**
   - **Decision:** Manual serving in fetch handler
   - Gives full control over SPA fallback and cache headers
   - Can optimize to `static` routes later if profiling shows it's needed

2. ~~**How to handle cache headers?**~~ **Resolved**
   - Implementation added in Phase 2 code above

3. **Is `Bun.embeddedFiles` needed as fallback?**
   - Not needed for primary implementation
   - Useful for debugging: `console.log(Bun.embeddedFiles)` to verify files embedded

4. **Content-Type for .js files**
   - Bun returns `text/javascript;charset=utf-8`
   - Modern standard prefers `application/javascript`
   - Both work in browsers - not a blocking issue

## References

- [Bun File Types Documentation](https://bun.sh/docs/runtime/file-types)
- [Bun Bundler - Executables](https://bun.sh/docs/bundler/executables)
- [Current embed-assets.ts](../scripts/embed-assets.ts)
